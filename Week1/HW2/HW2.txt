HW2
[Prob_1]--------------------------------------------------------------------------------------
=====編譯方式=====
g++ -fdiagnostics-color=always -g /home/ting/Documents/Week1/HW2/Problem_1_sol.cpp -o /home/ting/Documents/Week1/HW2/Problem_1_sol.out

./Problem_1_sol.out

=====輸入=====
[5,7,7,8,8,10]	, target=8	, OutPut=[3,4]
[5,7,7,8,8,10]	, target = 6	, OutPut:[-1,-1]
[5,7,7,8,7,8,8,10], target = 8	, OutPut:[3,6]
[5,7,7,8,7,8,8,10], target = 7	, OutPut:[1,4]

=====時間複雜度=====
O(log n)，利用二元搜尋的方式，查找目標數字的最小/最大index，
先將input的array分成前半部以及後半部，分別從頭以及最尾部尋找，找到之後就更新index的值

[Prob_2]--------------------------------------------------------------------------------------
=====編譯方式=====
g++ -fdiagnostics-color=always -g /home/ting/Documents/Week1/HW2/Problem_2_sol.cpp -o /home/ting/Documents/Week1/HW2/Problem_2_sol.out

./Problem_2_sol.out

=====輸入=====
babad 	, OutPut: aba
cbbd 	, OutPut: bb
hellowordrow , OutPut: wordrow 

=====方法=====
1.用一個迴圈跑string中的每一個字元
2.每次跑到的index視為回文的中心點查找
3.回文分為奇數或偶數-奇數:則中間開始的左右+-j都必須相同，ex.abcba
	          -偶數:則最中間的會與右邊的相同，接續往左右類推，ex.abba
4.接著判斷找出的回文是否為最長的，有的話更新

[Prob_3]--------------------------------------------------------------------------------------
=====編譯方式=====
g++ -fdiagnostics-color=always -g /home/ting/Documents/Week1/HW2/Problem_3_sol.cpp -o /home/ting/Documents/Week1/HW2/Problem_3_sol.out

./Problem_3_sol.out

=====輸入=====
[1,3]/[2] , OutPut:2
[1,2]/[3,4] , OutPut:2.5 

=====時間複雜度=====
1.確保arry1比較短，如果沒有的話將兩個順序對調
2.特殊情況先處理:如果兩個array有一個為空，直接計算其餘另一個的中位數。利用%2判斷機偶決定要不要相加/2。
3.之後使用二元搜尋
先找到切割點cut1,cut2，再利用切割點確定中位數的左右邊界值（l1 和 r1 分別為 nums1 在 cut1 左右的值，如果超出範圍則為 INT_MIN 或 INT_MAX），最後利用邊界值長度(是奇數還是偶數)判斷要不要相加/2。
4.如果沒有找到適合的切割點就要調整切割點cut1+/-1，繼續查找。
時間複雜度O(log(m+n))，使用二元搜尋，不用將兩個array進行合併再遍歷，直接使用已經排序好的兩個array用兩個分割點來尋找中位數的位置。




